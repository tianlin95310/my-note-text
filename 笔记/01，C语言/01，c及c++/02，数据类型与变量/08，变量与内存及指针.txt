//extern "C" int __cdecl printf(const char *, ...);
#include<stdio.h>


32位操作系统有4GB地址空间，每一个地址上都对应一个字节的内容，内存本身有8个16进制数，即4个字节
如下面的图

void main()
{	//"{"已经给变量分配了所有的空间，并将初始值赋值为“cc”， 
	printf("hello world!\n");
				//变量本身对应内存的一块地址上的内容,其上可以赋值
	char x = 0x12;		//占用1个字节，浪费3个字节	总共4个字节，并将第一个地址的内容赋值为12，空了3个
	short y = 0x6789;	//占用2个字节，浪费2个字节
	int z = 0x123456;	//占用4个字节，其高位补00，从右往左填。
	
	int a;		//该句话再执行大括号时已经执行了。
	a = 10;
	int b = 10;	//此句只做b = 10;
	
	char *px = &x;	//px赋值为x的首地址，px存的是x的地址，其本身也需要占用4个字节的地址
	short *py = &y;	//x的地址是：0012FF7C，故px的值也是0012FF7C，px的地址0012ff70，
	int *pz = &z;	//z占4个字节，(&z)0012ff74是它的首地址，pz存的也是z的首地址。取z的内容时，按照首地址取出4个
	
	char a = *px;	//*px是从px所对应的首地址开始取内容，px是char*型的，故从首地址开始，取一个内容
	short b = *py;	//py是short*型的，会从首地址开始取两个内容。
	int c = *pz;
指针加法的特殊性：
	px++;		//假设px为0012ff60，p++后，其为0012ff61
	py++;		//假设py为0012ff60，p++后，其为0012ff62
	pz++;		//其加1的情况是加上sizeof（type），

}

	folat x;占用4个字节，其占用内存形式与整型相同。但其表示不同
	计算机内部浮点数的表示方法与整数不同，相同的数字表达的数值可能不同
	浮点数采用IEEE754标准由S，E，M三部分组成。
	double y;
		对于浮点数，float f = 3.5e38;超过范围编译错误的。
		而整数不会，因为他们内部存贮机制不同。

2，指针的特殊性
	对于基本类型，数组，结构体，联合体，枚举，等类型的变量取地址加1，就是下一组数据的地址
	指针的++操作，真正加了多少，取决指针管辖的内存大小，这就为集合的迭代器提供了理论基础。

3，const修饰指针	
const char* p,char* const p;的区别
如果const位于星号的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；
如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。



/*
   内存地址 1，2，3，4		
  0012FF60  89 67 CC CC			
  0012FF64  00 CC CC CC		//0012ff64对应的是00，0012ff65对应cc，
  0012FF68  74 FF 12 00		//0012ff66对应cc，0012ff67对应cc
  0012FF6C  78 FF 12 00		//该地址即对应主存（内存，RAM）空间的的地址
  0012FF70  7C FF 12 00
  0012FF74  56 34 12 00
  0012FF78  89 67 CC CC
*/