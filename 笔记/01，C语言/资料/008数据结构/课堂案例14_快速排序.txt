/*
快速排序（Quicksort）是对冒泡排序的一种改进。由C. A. R. Hoare在1962年提出。
它的基本思想是：通过"一趟排序"将要排序的数据分割成独立的两部分，其中左部分
的所有数据都比右部分的所有数据都要小，然后再按此方法对这两部分数据分别进行
快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

算法过程
　　设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用第一个数
据）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它
后面，这个过程称为一趟快速排序。
	值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的
相对位置也许会在算法结束时产生变动。

 一趟快速排序的算法是：
 　　1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；
 　　2）以第一个数组元素作为关键数据，赋值给key，即 key=A[0]；
		注意该key值在整个过程中永远不变，始终是和key进行比较
 　　3）从j开始由后向前搜索，找到第一个小于key的值A[j]，并与A[i]交换；
 　　4）从i开始由前向后搜索，找到第一个大于key的值A[i]，并与A[j]交换；
 　　5）重复第3、4步，直到i=j；

注意:
	3)和4)步是在程序中没找到时候才j--和i++，直至找到为止。
	找到并交换的时候i和j指针位置不变。

key = 49
49i 38 65 97 76 13 27j

27i 38 65 97 76 13 49j
27 38 49i 97 76 13 65j

27 38 13i 97 76 49j 65
27 38 13 49i 76 97j 65

27 38 13 49ij 76 97 65
*/

#include <stdio.h>
#define DIM(x) sizeof(x) / sizeof(x[0])
#define SWAP(x, y) x = (y + x) - (y = x)
#define MID(x, y, z) (y < x && x < z) ? x : (x < y && y < z ? y : z)

//输入:a(int[]) - 要排序的数组
//	   nMin(int) - 第一个下标
//	   nMax(int) - 最后一个下标
//输出:int - 基准所在下标位置
//功能:分离数组并就地排序
//一趟快速排序法
int Partition(int a[], int nMin, int nMax)
{
	//int nKey= MID(a[nMin], a[nMax], a[(nMin+nMax)>>1]);	//平衡快排: 取中值做为Key
	int nKey= a[nMin];	//49

	int i = nMin;
	int j = nMax;
	do
	{
		//由后向前找到第一个比nKey小的元素, 并与a[i]交换
		while (a[j] >= nKey && i < j)
		{
			j--;
		}
		if (i < j) SWAP(a[i], a[j]);

		//由前向后找到第一个比nKey大的元素, 并与a[j]交换
		while (a[i] <= nKey && i < j)
		{
			i++;
		}
		if (i < j) SWAP(a[i], a[j]);

	} while (i < j);

	return j;
}

/*
key = 27
j = -1
j49i 38 65 97 76 13 27
j49 38 65 97 76 13i 27
49j 38 65 97 76 13i 27
13j 38 65 97 76 49i 27
13 38j 65 97 76 49i 27
13 27j 65 97 76 49i 38
*/
//另外一种一趟快速排序法
int Partition2(int a[], int nMin, int nMax)
{
	int nKey = a[nMax];
	int j = nMin - 1;
	for (int i = nMin; i <= nMax - 1; i++)
	{
		if (a[i] <= nKey)
		{
			j++;
			SWAP(a[i], a[j]);
		}
	}
	j++;

	SWAP(a[j], a[nMax]);

	return j;
}

/*
输  入: a(int[]) - 要排序的数组
		nMin(int) - 第一个下标
		nMax(int) - 最后一个下标
输  出: 无
功  能: 快速排序法
*/
void QuickSort(int a[], int nMin, int nMax)
{
	if (nMin >= nMax) return;
	if (nMin + 1 == nMax)	// 若只有两个元素,直接比较
	{
		if (a[nMin] > a[nMax]) SWAP(a[nMin], a[nMax]);
		return;
	}

	int j = Partition(a, nMin, nMax);
	QuickSort(a, nMin, j - 1);	//left
	QuickSort(a, j + 1, nMax);	//right
}

void main()
{
	int x[] = {49, 38, 65, 97, 76, 13, 27};

	QuickSort(x, 0, DIM(x)-1);

	for (int i = 0; i < DIM(x); i++)
	{
		printf("%d  ", x[i]);
	}
	printf("\r\n");
}

/*
快速排序的变种算法

随机化快排：
	快速排序的最坏情况基于每次划分对主元的选择。基本的快速
排序选取第一个元素作为主元。这样在数组已经有序的情况下，每次划分将
得到最坏的结果。一种比较常见的优化方法是随机化算法，即随机选取一个
元素作为主元。这种情况下虽然最坏情况仍然是O(n^2)，但最坏情况不再依
赖于输入数据，而是由于随机函数取值不佳。实际上，随机化快速排序得到
理论最坏情况的可能性仅为1/(2^n)。所以随机化快速排序可以对于绝大多
数输入数据达到O(nlogn)的期望时间复杂度。一位前辈做出了一个精辟的总
结："随机化快速排序可以满足一个人一辈子的人品需求。"
 　　随机化快速排序的唯一缺点在于，一旦输入数据中有很多的相同数据，
随机化的效果将直接减弱。对于极限情况，即对于n个相同的数排序，随机
化快速排序的时间复杂度将毫无疑问的降低到O(n^2)。解决方法是用一种
方法进行扫描，使没有交换的情况下主元保留在原位置。

平衡快排（Balanced Quicksort）：
	每次尽可能地选择一个能够代表中值的元素作为关键数据，然后遵循普
	通快排的原则进行比较、替换和递归。通常来说，选择这个数据的方法
	是取开头、结尾、中间3个数据，通过比较选出其中的中值。取这3个值
	的好处是在实际问题（例如信息学竞赛……）中，出现近似顺序数据或
	逆序数据的概率较大，此时中间数据必然成为中值，而也是事实上的近
	似中值。万一遇到正好中间大两边小（或反之）的数据，取的值都接近
	最值，那么由于至少能将两部分分开，实际效率也会有2倍左右的增加，
	而且利于将数据略微打乱，破坏退化的结构。

外部快排（External Quicksort）：
	与普通快排不同的是，关键数据是一段buffer，首先将之前和之后的M/2
	个元素读入buffer并对该buffer中的这些元素进行排序，然后从被排序数
	组的开头（或者结尾）读入下一个元素，假如这个元素小于buffer中最小
	的元素，把它写到最开头的空位上；假如这个元素大于buffer中最大的元
	素，则写到最后的空位上；否则把buffer中最大或者最小的元素写入数组，
	并把这个元素放在buffer里。保持最大值低于这些关键数据，最小值高于
	这些关键数据，从而避免对已经有序的中间的数据进行重排。完成后，数
	组的中间空位必然空出，把这个buffer写入数组中间空位。然后递归地对
	外部更小的部分，循环地对其他部分进行排序。
三路基数快排（Three-way Radix Quicksort，也称作Multikey Quicksort、
	Multi-key Quicksort）：结合了基数排序（radix sort，如一般的字符串比较
	排序就是基数排序）和快排的特点，是字符串排序中比较高效的算法。该算法
	被排序数组的元素具有一个特点，即multikey，如一个字符串，每个字母可以
	看作是一个key。算法每次在被排序数组中任意选择一个元素作为关键数据，首
	先仅考虑这个元素的第一个key（字母），然后把其他元素通过key的比较分成小
	于、等于、大于关键数据的三个部分。然后递归地基于这一个key位置对"小于"
	和"大于"部分进行排序，基于下一个key对"等于"部分进行排序。
*/