1,继承限制
  1，java只能实现单继承，一个派生类不能有多个父类，但c++可以有。例如菱形结构
  2，允许多层继承
  3，构造方法不能被继承
  4，类和接口会默认继承Object类，所以他们的子类都是Object的子类

2，覆盖

	1，派生类的成员覆盖的基类的成员,只是名字覆盖而已,内存中还是有两份的
	2，派生类的函数重写基类的函数，（函数签名完全一致，多态的条件之一）

	3，构造函数的特殊性：
	存在继承关系时，子类的构造函数里会默认有super()语句，会默认调用父类的无参构造函数
	当父类有无参构造时，super写与不写是一样，都会默认含有，但当父类没有无参构造函数时，子类必须要显示指定父类的构造函数
	c++也是这样的，父类的构造函数是用于子类实例化的

	4，关于private继承的问题，
	子类不能显示的调用private成员，但从基类继承的一些public方法
	是可以操作这些成员的，父类的这些方法已经固定下来存到了方法区，子类对象调用时，调出来即可
如
class B
{
	private String name;
	public B(String name)
	{
		this.name = name;
	}
}

class A extends B
{
	public A(String name)
	{
		super(name);
	}
}

3，关于对继承的理解
	1，基类的private属性，子类也是能继承的，只是在子类中不能显示的访问，求子类类型的内存占用时，
	private属性也是被算在内存里的，这与c++是一样的，包括属性的覆盖时，子类也是包含那个覆盖的属性的，对外覆盖，但占有内存

	2，在有继承关系的类间的某一次实例化中，只会产生一个对象，并且不管是父类中的属性还是子类中的属性都是
	当前对象的，属性名覆盖时属性的相对位置就在子类中，显示的调用基类的非private属性时（this,super,直接调用），或者通过get方法
	得到从基类继承的属性，都是以子类为基准来看能否访问属性对应的类，因为对象此时在子类中，自然以子类为基准

	3，关于方法，方法的继承是让子类能有访问的权限，只要子类能知道函数的入口地址，便能访问到函数，
	继承的方法他仍然是在基类中，他仍然是基类的方法，相对位置也是在父类中，父类方法能否访问其他类，
	这在基类中就已经定义好了，他是以基类为参考基准的。如果子类重写了基类的方法
	此时方法的相对位置便在子类中，能否访问其他类自然也以子类为基准




